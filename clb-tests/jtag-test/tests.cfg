source ./setup.cfg
source ./init.cfg

# LUTRAM Tests

# Extract n-th bit from num
proc bit_extract {num n} {
    return [expr {($num >> $n) & 0x1}]
}

# Deinterleaves two n-bit integer values a and b, starting with a
# Args:
#  - n: bit length of a and b
#  - a: first interleaved integer component
#  - b: second interleaved integer component
# Returns (n*2)-bit deinterleaved number
proc deinterleave_bits {n a b} {
    set ret 0
    for {set i 0} {$i < $n} {set i [expr {$i + 1}]} {
        set ret [expr {([bit_extract $b $i] << ($i*2 + 1)) | ([bit_extract $a $i] << ($i*2)) | $ret}]
    }
    return $ret
}

# Extracts n-th bit of each sample in the samples list
# Args:
#  - samples: list of samples
#  - n: n-th bit to extract from a sample
# Returns a list of extracted 1-bit values
proc bits_mux {samples n} {
    set ret {}
    foreach sample $samples {
        lappend ret [bit_extract $sample $n]
    }
    return $ret
}

# Assemble a number from bit_list such that n-th bit of the number maps to
# n-th entry in bit_list
# Args:
#  - bit_list: list of 1-bit samples; length of list cannot exceed 64-bits.
# Returns a number created from bit_list
proc assemble_from_bit_list {bit_list} {
    set ret 0
    for {set i 0} {$i < [llength $bit_list]} {set i [expr {$i + 1}]} {
        set ret [expr {([lindex $bit_list $i] << $i) | $ret}]
    }
    return $ret
}

# Prints test results of each output data port
proc print_test_result {result_list} {
    for {set i 0} {$i < [llength $result_list]} {set i [expr {$i + 1}]} {
        echo "lutram_do\[$i\]: [lindex $result_list $i]"
    }
}

# LUTRAM INIT Tests

# Checks INIT pattern of single- or dual-read-port LUTRAM
# Args:
#  - n: bit length of LUTRAM's INIT pattern (as multiple of 32)
#  - num_outputs: 1 or 2
proc test_lutram_init {n num_outputs} {
    global lutram_init_list
    set result {}
    for {set i 0} {$i < $num_outputs} {set i [expr {$i + 1}]} {
        lappend result PASS
    }
    # compare 32-bits at a time
    set end [expr {$n / 32}]
    for {set i 0} {$i < $end} {set i [expr {$i + 1}]} {
        # INIT[(i+1)*32-1:i*32]
        set init32_pattern [lindex $lutram_init_list $i]
        set addr [expr {$i * 32}]
        set samples [read_lutram_range $addr 32]
        for {set port 0} {$port < $num_outputs} {set port [expr {$port + 1}]} {
            set lutram_pattern [assemble_from_bit_list [bits_mux $samples $port]]
            if {$init32_pattern != $lutram_pattern} {
                echo "port $port: got [format 0x%x $lutram_pattern] but expected [format 0x%x $init32_pattern]"
                lset result $port FAIL
            }
        }
    }
    return $result
}

proc test_RAMS32_init {} {
    return [test_lutram_init 32 1]
}

proc test_RAMD32_init {} {
    # RADR=WADR
    return [test_RAMS32_init]
}

proc test_RAM32X1S_init {} {
    return [test_RAMS32_init]
}

proc test_RAM32X1D_init {} {
    # RADR=WADR
    return [test_lutram_init 32 2]
}

proc test_RAMS64E_init {} {
    return [test_lutram_init 64 1]
}

proc test_RAM64X1S_init {} {
    return [test_RAMS64E_init]
}

proc test_RAM64X1D_init {} {
    # RADR=WADR
    return [test_lutram_init 64 2]
}

proc test_RAM128X1S_init {} {
    return [test_lutram_init 128 1]
}

proc test_RAM128X1D_init {} {
    # RADR=WADR
    return [test_lutram_init 128 2]
}

proc test_RAM256X1S_init {} {
    return [test_lutram_init 256 1]
}

proc test_RAM32M_init {} {
    global lutram_init_list
    set result {PASS PASS PASS PASS PASS PASS PASS PASS}
    # compare 32-bits at a time
    for {set i 0} {$i < 2} {set i [expr {$i + 1}]} {
        set addr [expr {$i * 16}]
        set samples [read_lutram_range $addr 16]
        # For each port group
        for {set port_group 0} {$port_group < 4} {set port_group [expr {$port_group + 1}]} {
            set offset [expr {$port_group * 64}]
            # INIT[(i+1)*32 + offset - 1:i*32 + offset]
            set init_index [expr {($offset / 32) + $i}]
            set init32_pattern [lindex $lutram_init_list $init_index]

            set lower16_pattern [assemble_from_bit_list [bits_mux $samples [expr {$port_group*2}]]]
            set upper16_pattern [assemble_from_bit_list [bits_mux $samples [expr {$port_group*2+1}]]]
            set lutram32_pattern [deinterleave_bits 16 $lower16_pattern $upper16_pattern]
            if {$init32_pattern != $lutram32_pattern} {
                echo "port group $port_group: got [format 0x%x $lutram32_pattern] but expected [format 0x%x $init32_pattern]"
                lset result [expr {$port_group*2}] FAIL
                lset result [expr {$port_group*2+1}] FAIL
            }
        }
    }
    return $result
}

proc test_RAM64M_init {} {
    global lutram_init_list
    set result {PASS PASS PASS PASS}
    # compare 32-bits at a time
    for {set i 0} {$i < 2} {set i [expr {$i + 1}]} {
        set addr [expr {$i * 32}]
        set samples [read_lutram_range $addr 32]
        # For each port group
        for {set port_group 0} {$port_group < 4} {set port_group [expr {$port_group + 1}]} {
            set offset [expr {$port_group * 64}]
            # INIT[(i+1)*32 + offset - 1:i*32 + offset]
            set init_index [expr {($offset / 32) + $i}]
            set init32_pattern [lindex $lutram_init_list $init_index]

            set lutram_pattern [assemble_from_bit_list [bits_mux $samples $port_group]]
            if {$init32_pattern != $lutram_pattern} {
                echo "port group $port_group: got [format 0x%x $lutram_pattern] but expected [format 0x%x $init32_pattern]"
                lset result $port_group FAIL
            }
        }
    }
    return $result
}

echo "tests.cfg loaded"
